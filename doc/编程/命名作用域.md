命名作用域

作用域决定了哪些变量可以从哪里访问。简单来说，作用域就是一个从名称到值的映射。
JavaScript 的作用域规则与 Python 类似，但也有一些关键区别。

首先存在 1 个全局作用域，其次每个函数都会创建自己的局部作用域（函数作用域）。
在 ES6 中，let 和 const 还会创建块级作用域。

在函数外定义的变量属于全局作用域：

let x = 1
// 在全局作用域中将值 1 赋给名称 x

以下函数定义在全局作用域中，将一个函数赋给名称 f：

function f() {
	// 在 f 的局部作用域中将值 1 赋给名称 y
	let y = 1

	// 在 f 的局部作用域中将一个函数赋给名称 g
	function g() {
		// ...
	}
}

f()
// 从全局作用域中检索存储在 f 中的函数并调用它

console.log(y)
// 这会抛出错误，因为 y 只存在于 f 的局部作用域中，
// 无法在全局作用域中访问

全局变量与局部变量

默认情况下，函数中的变量如果使用 let 或 const 声明，则属于局部作用域，即使全局作用域中存在同名变量。

let x = 0

function f() {
	let x = 1
}
f()
console.log(x)

这段代码会打印 0，因为 f 内部的局部 x 与全局 x 不是同一个变量。

如果想修改全局变量，有两种方法：

方法一：省略 let/const（不推荐，一般会造成 bug）  
方法二：明确访问全局对象上的变量，如 window.x（浏览器环境）

let x = 0

function f() {
	// ⚠ 不推荐：未使用 let/const，会直接写入全局变量
	x = 1
}
f()
console.log(x) // 打印 1

浏览器环境中的严格模式（默认启用）下，未声明的变量赋值会报错，因此全局污染通常被禁止。

循环和分支

使用 var 声明的变量没有块级作用域，因此在循环或分支外仍然能访问：

for (var i = 0; i < 3; i++) {
	// ...
}
console.log(i)
// 打印 3，因为 var 不具备块级作用域

let 和 const 则具有块级作用域：

for (let j = 0; j < 3; j++) {
	// ...
}
console.log(j)
// 这会抛出错误，因为 j 不在该作用域内

在 JavaScript 中：
- var → 函数作用域  
- let / const → 块级作用域  
- function → 总是创建函数级作用域  

理解这些作用域规则对于写出可维护的代码非常重要。
